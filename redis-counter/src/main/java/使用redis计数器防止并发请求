需求描述

      最近项目中有个需求，短信发送的并发请求问题：业务需求是需要限制一个号码一分钟内只能获取一次随机码，之前的实现是短信发送请求过来后，先去数据库查询发送记录，根据上一次的短信发送时间和当前时间比较，如果时间差小于一分钟，则提示短信获取频繁，如果超过一分钟，则发送短信，并记录短信发送日志。

问题分析

      短信发送是一个很敏感的业务，上面的实现存在一个并发请求的问题，当同一时间有很多请求过来时，同时去查库，同时获取到上一次发送时间没有，或者已超过一分钟，这时候就会重复发送短信了。

使用Redis incr解决问题

      Redis incr 可以实现原子性的递增，可应用于高并发的秒杀活动、分布式序列号生成等场景。这里我使用它来计数实现一分钟内只接受一次请求。

      实现逻辑也很简单：我们在接到短信发送请求后，使用Redis的incr设置一个递增KEY（KEY由固定字符串+手机号码组成），并判断该KEY的数值，如果等于1，说明是第一个请求，我们将该KEY值有效期设置为一分钟；如果该KEY的数值大于1，说明是1分钟内的多次请求，这时我们直接返回短信获取频繁，代码如下：


String redisKey = "SMS_LIMIT_" + smsPhone;
long count = redisTemplate.opsForValue().increment(redisKey, 1);
if (count == 1) {
//设置有效期一分钟
  redisTemplate.expire(redisKey, 60, TimeUnit.SECONDS);
}
if (count > 1) {
   resultMap.put("retCode", "-1");     
   resultMap.put("retMsg", "每分钟只能发送一次短信");
   outPrintJson(resultMap);
   return;
}
/** 发送短信 */
......
/** 记录发送日志 */
......
测试

      使用Jmeter进行并发测试，同时发送200个线程请求，通过测试发现可避免并发请求问题 ：
测试图1
查看结果，只有第一个请求发送了短信，剩余199个请求均返回失败：
测试图2
可以看出性能还是很不错的：